# elixir
![](media/15078163727288.jpg)

elixir 原子可以用来直接引用 Erlang 标准库的模块，包括内置的模块。
![](media/15080820735472.jpg)


[Add new element to list-- improper list](https://stackoverflow.com/questions/35528875/add-new-element-to-list)


case中的模式匹配

```elixir
iex(20)> case {1,2,3} do
...(20)>  {4,5,6} -> "won't match"
...(20)>  {1,x,3} -> "bind x to 2. the x = #{x}"
...(20)> end
"bind x to 2. the x = 2"
```
模式匹配将绑定被匹配的变量

```elixir
iex(30)> case 10 do
...(30)>  y -> "matched the y = #{y}"
...(30)> end
"matched the y = 10"
```
当为单变量匹配的时候，最容易出错，因为任何时候都相当于 x=#{matchItem} 是等号赋值的操作，所以一定要使用`^x`进行之前值的匹配


```elixir
iex(32)> x = 1
1
iex(33)> case 10 do
...(33)>  x -> "shouldn't matched ! but matched and the x = #{x}!!! "
...(33)>  _ -> "will match"
...(33)> end
"shouldn't matched ! but matched and the x = 10"
iex(34)> x
1
```


```elixir
iex(35)> x = 1
1
iex(36)> case 10 do
...(36)>  ^x -> "won't match"
...(36)>  _ -> "will match"
...(36)> end
"will match"
```



```elixir
iex(43)> x
1
iex(44)> case [1,2,3] do
...(44)>  [1,x,3] -> "x match"
...(44)>  _ -> "match"
...(44)> end
"x match"
iex(45)> x
1
iex(46)> case [1,2,3] do
...(46)>  [1,^x,3] -> "x match"
...(46)> _ -> "will match"
...(46)> end
"will match"
iex(47)>
```

匿名函数与模式匹配

```elixir
iex(49)> f = fn
...(49)>  x,y when x>0 -> x+y
...(49)>  x,y -> x*y
...(49)> end
#Function<12.99386804/2 in :erl_eval.expr/5>
iex(50)> f.(1,3)
4
iex(51)> f.(-1,3)
-3
```

在匿名函数中的case模式匹配需要参数个数一致。
```elixir
iex(53)> case {1,2,3} do
...(53)>  {4,5,6} -> "won't match"
...(53)>  {1,x} -> "match?"
...(53)>  _ -> "default"
...(53)> end
"default"
iex(54)> f = fn
...(54)>  x,y when x>0 -> x*y
...(54)>  x,y,z -> x*y*z
...(54)> end
** (CompileError) iex:54: cannot mix clauses with different arities in anonymous functions
```

elixir的关键字列表
```elixir
iex(59)> if true do
...(59)>  "true"
...(59)> else
...(59)>  "false"
...(59)> end
"true"
iex(60)> if true, do
** (SyntaxError) iex:60: unexpected token "do". In case you wanted to write a "do" expression, you must either separate the keyword argument with comma or use do-blocks. For example, the following construct:

    if some_condition? do
      :this
    else
      :that
    end

is syntactic sugar for the Elixir construct:

    if(some_condition?, do: :this, else: :that)

where "some_condition?" is the first argument and the second argument is a keyword list.

Syntax error before: do

iex(60)> if true, do: "true"
"true"
```

代码61和62等同
```elixir
iex(60)> if true, do: "true"
"true"
iex(61)> if true, do: 1+2
3
iex(62)> if true do
...(62)>  1+2
...(62)> end
3
```


```elixir
iex(1)> if true do
...(1)>  a = 10
...(1)>  a = 10 + 90
...(1)> end
100

iex(3)> if true, do: (
...(3)>  a = 10
...(3)>  a = 10 + 90
...(3)> )
100
```


```elixir
iex(5)> if true do
...(5)>  :this
...(5)> else
...(5)>  :that
...(5)> end
:this

iex(6)> if true, do: :this, else: :that
:this
```


