---
layout: post
title: 004-Go基础之二 流程控制
category: golang架构师之路
tags: golang,tour,function,variables,package
keywords: package,tour,function,variables 
---

**流程控制语句**: `for,if,else,switch and defer`  
学习如何使用条件、循环、开关分支、推迟语句控制代码流程

## for循环
### for基本组成
**Go只有一种循环结构，即for循环**   
基本的for循环由分号分隔成三部分组成:
- 初始化部分:第一次迭代之前执行
- 条件表达式部分:每次迭代之前计算求值
- 后置部分:每次迭代之后执行

初始化部分通常是简短的变量声明，并且被声明的变量只能在for语句块范围内可见。

当条件表达式值为false时，循环就会终止。  

注意：Go的for循环和其他语言比如C，Java，JavaScript不一样，没有且并不需要括号()括起来其组成的三部分，并且循环体{}不能少。   

```go
package main

import "fmt"

func sum() int {
	sum := 0
	for i := 0; i <= 10; i++ {
		sum += i
		fmt.Printf("i=%v, sum=%v\n", i, sum)
	}
	return sum
}

func main() {
	fmt.Printf("sum:%v\n", sum())
}

// i=0, sum=0
// i=1, sum=1
// i=2, sum=3
// i=3, sum=6
// i=4, sum=10
// i=5, sum=15
// i=6, sum=21
// i=7, sum=28
// i=8, sum=36
// i=9, sum=45
// i=10, sum=55
// sum:55
```

### for组成的可选部分
初始部分和后置部分都是可选的。
```go
package main

import "fmt"

func sum() int {
	sum := 1
	for ; sum < 1000; {
		sum += sum
		println(sum)
	}
	return sum
}

func main() {
	fmt.Println(sum())
}
// 1024
// 2
// 4
// 8
// 16
// 32
// 64
// 128
// 256
// 512
// 1024
```

### for是Go语言的"while"
基于此你可以省略分号：Go语言的`for`等同于C语言的`while`，也就是说前置短声明变量与后置语句的省略，再去除分号，**可以只保留条件表达式部分，等价于while循环**
```go
func sum() int{
	sum := 1
	for sum<1000 {
		sum += sum
	}
	return sum
}
```

可以使用while循环重写高斯算和的案例

```go
package main

import "fmt"

func sum() int {
	sum := 0
	i := 0
	for i <= 10 {
		sum += i
		fmt.Printf("i=%v, sum=%v\n", i, sum)
		i++
	}
	return sum
}

func main() {
	fmt.Printf("sum:%v\n", sum())
}

// i=0, sum=0
// i=1, sum=1
// i=2, sum=3
// i=3, sum=6
// i=4, sum=10
// i=5, sum=15
// i=6, sum=21
// i=7, sum=28
// i=8, sum=36
// i=9, sum=45
// i=10, sum=55
// sum:55
```

### 死循环
如果省略表达式条件将会永远循环下去，所以更简单直接的表达就是死循环。

```go
func main() {
	for{} // infinite for loop
	//for ; ;  {}
}
```

## if语句
Go的`if`语句块与它的`for`循环类似；表达式不需要被括号括起来，但是需要`{}`括起`if`执行体。  

```go
package main

import (
	"fmt"
	"math"
)

func sqrt(f float64) string {
	fmt.Printf("%v\n", f)
	if f < 0 {
		return sqrt(-f)
	}
	return fmt.Sprint(math.Sqrt(f),9999)
}

func main() {
	fmt.Printf("%v, %v", sqrt(2), sqrt(-4))
}

// 2
// -4
// 4
// 1.4142135623730951 9999, 2 9999
```

## 带有简短语句块的if
像`for`循环一样，`if`语句可以在条件表达式之前先执行一个简短的语句。  
在这个简短的表达式块中声明的变量生命周期只在`if`块中。  

```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Printf("%v\n", pow(2, 3, 10))// 8
	fmt.Printf("%v", pow(3, 2, 6))// 6
}
```

## if else
变量声明可以在if的简短语句中也可以在else语句块中。  

```go
package main

import "fmt"

func pow(x, n, lim float64) float64 {
	if fmt.Printf("%q\n", "if,else执行前都要先执行"); 1 < lim {
		return 1
	} else {
		fmt.Printf("%g >= %g\n", 1, lim)
	}
	return lim
}

func main() {
	fmt.Printf("%v\n", pow(2, 3, 10))
	fmt.Printf("%v", pow(3, 2, -1))
}

// "if,else执行前都要先执行"
// 1
// "if,else执行前都要先执行"
// %!g(int=1) >= -1
// -1
```
在 main方法 的 `fmt.Println` 调用开始前，两次对 `pow` 的调用均已执行并返回。

```go
package main

import "fmt"

func pow(x, n, lim float64) float64 {
	if 1 < lim {
		return 1
	} else if fmt.Printf("%q\n", "if,else执行前都要先执行"); 1>0 {
		fmt.Printf("%g >= %g\n", 1, lim)
	}
	return lim
}

func main() {
	fmt.Printf("%v\n", pow(2, 3, 10))
	fmt.Printf("%v", pow(3, 2, -1))
}

// 1
// "if,else执行前都要先执行"
// %!g(int=1) >= -1
// -1

```

## 练习：循环与函数

我们来简单练习一下函数和循环：用牛顿法实现平方根函数。 
在本例中，牛顿法是通过选择一个起点 z 然后重复以下过程来求 Sqrt(x) 的近似值：
`z = z - (z*z - x) / (2*z)`  
为此只需重复计算 10 次，并且观察不同的值（1，2，3，……）是如何逐步逼近结果的。 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数是否变化。结果与 math.Sqrt 接近吗？ 
提示：用类型转换或浮点数语法来声明并初始化一个浮点数值： 
```go
z := float64(1) 
z := 1.0
``` 
 
```go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
	z := float64(x)
	for i := 0; i < 10; i++ {
		z = z - (z*z-x)/(2*x)
		fmt.Printf("%v\n", z)
	}
	return z
}

func main() {
	Sqrt(2)
}
```

精度控制版本:
```go
package main

import (
	"fmt"
	"math"
)

func Sqrt(x float64) float64 {
	z := float64(x)
	y := 0.0
	//y := float64(0)
	for {
		z = z - (z*z-x)/(2*x)
		if math.Abs(y - z) < 1e-10 {
			break
		}
		y = z
		fmt.Printf("%v\n", y)
	}
	return y
}

func main() {
	Sqrt(2)
}
```

## swtich语句
除非以 fallthrough 语句结束(全部判断一遍)，否则分支会自动终止(匹配则自动break)。switch语句在表达式之前也可以有语句执行

```go
package main

import (
	"runtime"
	"fmt"
)

func main() {
	switch os := runtime.GOOS; os {
	case "linux":
		println("case linux")
		fmt.Printf("%q", os)
	case "darwin":
		println("case darwin")
		fmt.Printf("%q", os)
	default:
		println("case default")
		fmt.Printf("%q", os)
	}
}
```

## switch计算求值顺序
switch的case语句自上而下顺序执行，直到匹配成功终止。  
例如:
```go
switch i {	
	case 0 :
	case f():
}
```
如果`i==0`，则不会再调用`f()`

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("when is saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Printf("today is saturday %q", today)
	case today + 1:
		fmt.Printf("tomorrday is saturday %q", today)
	case today + 2:
		fmt.Printf("in two days %q", today)
	default:
		fmt.Printf("too far away %q\n", today)
		fmt.Printf("too far away %v", today)
	}
	/*
	when is saturday?
	too far away "Wednesday"
	too far away Wednesday
	*/
}
```

## 不带条件的switch
没有条件的switch等同于`switch true`。这种形式能够将一长串`if-then-else`写得更清晰。  

```go
package main

import (
	"time"
	"fmt"
)

func main() {
	t := time.Now()

	switch  {
	case t.Hour() < 12:
		fmt.Printf("Good morning! %v", t.Hour())
	case t.Hour() < 17:
		fmt.Printf("Good afternoon! %v", t.Hour())
	default:
		fmt.Printf("Good evening! %v", t.Hour())
	}
}
```
案例2  

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	hour := t.Hour()
	
	if hour< 12 {
		fmt.Printf("morning: %v", hour)
	}

	if hour< 18 {
		fmt.Printf("afternoon: %v", hour)
	}

	if hour< 24 {
		fmt.Printf("evening: %v", hour)
	}

	switch {
	case hour< 12:
		fmt.Printf("morning: %v", hour)
	case hour< 18:
		fmt.Printf("afternoon: %v", hour)
	case hour< 24:
		fmt.Printf("evening: %v", hour)
	}
}
```
switch true中需要case的表达式为布尔表达式。

## defer
defer语句推迟到外层函数返回之前才执行。  
defer语句调用参数会立刻求值，但是函数直到外层函数返回之前是不会调用的。

```go
package main

import (
	"fmt"
)

func main() {
	defer fmt.Println(3 + 2)
	defer fmt.Println("Hello")
	fmt.Println("World")
}
```

## defer栈
推迟的函数调用被压入栈中。当一个函数返回，它将以last-in-first-out(先进后出或后进先出)的顺序调用。阅读[这篇文章](https://blog.golang.org/defer-panic-and-recover)可以学习更多defer相关内容。

```go
package main
import (
	"fmt"
)

func main() {
    fmt.Println("counting...")
	for i := 0; i< 10; i++ {
		defer fmt.Println(i)
	}
	fmt.Println("done.")
}
/**结果如下
counting...
done.
9
8
7
6
5
4
3
2
1
0
*/
```





