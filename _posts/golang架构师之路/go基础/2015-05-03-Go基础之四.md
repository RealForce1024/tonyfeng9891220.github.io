---
layout: post
title: 006-Go基础之四 方法和接口
category: golang架构师之路
tags: golang,method,interface
keywords: golang,method,interface
---

方法和接口
学习如何为类型定义方法;如何定义接口;以及如何将所有内容贯穿组织起来。  
学习了方法和接口，可以这种构造来定义对象及其行为。

## 方法
- **Go没有class类，可以为结构体类型定义方法**  
- 一个方法是含有特殊**接收器参数**的函数
- 接收器参数在它自己的参数列表中，位于`func`关键字和函数名中间。  

在下面的示例中，Abs方法有个命名为`v`的、类型为`Vertex`的接收器

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X float64
	Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
// 5
```

## 方法和函数
**方法只是函数多了个接收器参数。**  
下面的示例`Abs`写法就是个规则的函数，功能上没有任何的变化。  
但是从结构上来说，方法是结构体的一部分，和之后的接口定义实现是有联系的。
```go
package main

import (
	"math"
	"fmt"
)

type Vertex struct {
	X float64
	Y float64
}

/**
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
*/

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}

// 5
```

## 方法和类型
前面的案例可以为结构体类型构造方法，其实我们也可以不使用结构体类型。
下面的案例中我们可以看到带有`Abs`方法的数值类型`MyFloat`。  

**只能为同一包内定义的类型的接收器声明方法**。不能为其他包定义的类型(包括`int`等内建类型)的接收器声明方法。  

```go
type myInt int//必须单独定义一下，如果不定义别名的话，编译不过去。接收器必须是同一包内的。
func (x myInt) add(a,b int)  {}
```

```go
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}

// 1.4142135623730951

```

## 类型别名进阶
```go
package main

import fm "fmt"
func main() {
	fm.Println("hello world")
}
```
上述方式是最基本的取别名方式，简单易懂。  
Go通过取别名的方式对任意类型都可以添加方法。其实本质上就是 接收器可以为任意类型构造方法。

```go
package main

import fm "fmt"

type TP int

func (tpz *TP) Foo() {
	fm.Println("tpz")
}

func main() {
	var t TP = 100
	t.Foo() // method value
	(*TP).Foo(&t) // method expression
}

// tpz
```
底层类型为int，被我们绑定了Foo方法，可以看出go的灵巧之处。  接收器可以为任意类型~~构造~~(绑定)方法。 

底层为int类型的值调用自定义方法修改值。   
```go
package main

import "fmt"

type myInt int

/*func (x myInt) increase(y int)  {
	x+=myInt(y) //该案例没有原值改变，说明接收器的传递方式也是传值拷贝
}*/

func (x *myInt) increase(y int) {
	*x += myInt(y)
}

func main() {
	var a myInt = 10
	a.increase(100)
	fmt.Println(a)
}
```
注意：接收器是特殊的参数，但其传值方式与普通参数传值拷贝是一样的。
&取址，*取值

## 指针接收器
我们可以使用指针接收器定义方法，从面向对象的角度理解，也可以认为是**为指针接收器定义了方法**(更好理解些)。  
这意味着对于某种类型`T`，接收器类型拥有这样的的字面量`*T`。(当然，`T`不能是像`*int`这样的指针，是因为接收器必须定义在同一包下，而我们开发者自定义的肯定无法修改int作为接收器，自然不能是*int)。  

例如，为`*Vertex`接收器定义`Scale`方法。  
指针接收器的方法可以修改接收器指向的值(就如`Scale`方法所做)。**由于方法经常需要修改他们的接收器，所以指针接收器比值接收器更加通用**。  

试试从Scale方法移除`*`，并管着程序运行结果是如何变化的。  

使用值接收器的话，`Scale`方法将会操作原始`Vertex`的值的一份副本(对于其他函数的参数是一样的，**本质上也是一种针对副本的只读行为**)。Scale方法必须用指针接收器来更改main函数中声明的Vertex的值。

```go
package main

import (
	"math"
	"fmt"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{5,12}
	v.Scale(100)
	fmt.Println(v.Abs())
}

// 1300

```

## 指针和函数
上一节中的案例我们使用函数的方式重写以下。
```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v *Vertex) float64{
	return math.Sqrt(v.X*v.X+v.Y*v.Y)
}

func Scale(v Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3,4}
	Scale(&v,10)
	fmt.Println(Abs(v))
}

// 50
```

同样，我们再试试删除`Scale`方法的`*`。你知道为什么结果方式了变化吗?还需要哪些修改使该程序编译通过?

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func Scale(v Vertex, f float64) Vertex{
	v.X = v.X * f
	v.Y = v.Y * f
	return v
}

func main() {
	v := Vertex{3, 4}
	p := Scale(v, 10)
	fmt.Println(Abs(p))
}

```

## 方法和指针重定向(Methods and pointer indirection)
对比之前两小节的程序，你也会注意到了`带指针参数`的**函数**`必须接受一个指针`:  

```go
var v Vertex
ScaleFunc(v) // 编译错误
ScaleFunc(&v) // ok
```

但带指针的方法不论是值接收器还是指针接收器，当它们被调用时:

```go
var v Vertex
v.Scale(5) // ok
p := &v
p.Scale(10) // ok
```

对于语句`v.Scale(5)`，即使v是一个值并不是一个指针，指针接收器的方法也被自动地调用。也就是说，由于`Scale`方法有个指针接收器，作为便利，Go解释器将语句`v.Scale(5)`解析为`(&v).Scale(5)`

在相反的情况下是相同的。 `带值参数`的**函数**`必须接收一个特定类型的值`:  

```go
var v Vertex
fmt.Println(AbsFunc(v)) // OK
fmt.Println(AbsFunc(&v)) // Compile error!
```
但以值为接收器的方法当它们被调用时，接受者既可以为值也可以为指针:  

```go
var v Vertex
fmt.Println(v.Abs()) // OK  
p := &v
fmt.Println(p.Abs()) // OK
```

在这个案例中，方法调用`p.Abs()`被解释为`(*p).Abs()`
`*`操作符表示指针指向的底层值。  

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
	fmt.Println(AbsFunc(v))

	p := &Vertex{5, 12}
	fmt.Println(p.Abs())
	fmt.Println(AbsFunc(*p)) //*p 指针p底层的值
}

// 5
// 5
// 13
// 13
```

## 值或指针接收器的选择
有两个原因选择指针接收器。     
- 第一:方法可以修改指针所指向的值  
- 第二:避免每次方法调用都进行值拷贝。如果是大结构体类型的接收器这将会很高效。   

这次的示例中，`Scale`和`Abs`都使用`*Vertex`类型的接收器，即使`Abs`方法不需要修改它的接收器。

通常情况下，给定类型的方法都应该有值或指针接收器，但不应是两者的混合。

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	//v := &Vertex{3, 4}
	v := Vertex{3, 4}
	fmt.Printf("Before scaling: %+v, Abs: %v\n", v, v.Abs())
	v.Scale(10)
	fmt.Printf("After scaling: %+v, Abs: %v\n", v, v.Abs())

}

// Before scaling: {X:3 Y:4}, Abs: 5
// After scaling: {X:30 Y:40}, Abs: 50
```

## 变参的值拷贝

-

```go
package main

import (
	"fmt"
)

func main() {
	a, b := 1,2
	fmt.Println("改变前:-->", a,b)
	Change(a,b)
	fmt.Println("改变后:-->", a,b)
}
//func Change(x ...int) {
func Change(x ...int) {
	x[0] = 3
	x[1] = 4
	fmt.Println("改变中:-->", x)
}
// 改变前:--> 1 2
// 改变中:--> [3 4]
// 改变后:--> 1 2
```

```go
package main

import (
	"fmt"
)

func main() {
	a, b := 1, 2
	fmt.Println("改变前:-->", a, b)
	Change(&a, &b)
	fmt.Println("改变后:-->", a, b)
}

//func Change(x ...int) {
func Change(x ...*int) {
	*x[0] = 3
	*x[1] = 4
	fmt.Println("改变中:-->", x)
}
// 改变前:--> 1 2
// 改变中:--> [0xc42000e238 0xc42000e260]
// 改变后:--> 3 4
```
- 引用类型传参时也是值拷贝，注意拷贝的值是地址。并且需要注意的是，并非拷贝了指针。

```go
package main

import (
	"fmt"
)

func main() {
	s := []int{1, 2, 3}
	fmt.Println("改变前:-->", s)
	Change(s)
	fmt.Println("改变后:-->", s)
}
//func Change(x ...int) { //编译错误
func Change(x []int) {
	x[0] = 4
	x[1] = 5
	x[2] = 6
	fmt.Println("改变中:-->", x)
}

// [1 2 3]
// [4 5 6]
// [4 5 6]
```

## go中一切皆值
函数也是值，类型则是函数类型。简而言之，函数类型也是值  
`a := 3  // 3是int类型的值`  
`f := FuncName // f是func类型的值`

```go
package main

import "fmt"

func main() {
	a := A
	a()
}

func A() {
	fmt.Println("A()")
}
// A()
```

### 匿名函数

```go
package main

import "fmt"

func main() {
	a := func() {
		fmt.Println("A()")
	}
	a()
}
// A()
```

### 闭包

```go
package main

import "fmt"

func main() {
	f := closure(10)
	fmt.Println(f(1))
	fmt.Println(f(2))
}

func closure(x int) func(y int) int {
	fmt.Printf("%p %v \n", &x, x)
	return func(y int) int {
		fmt.Printf("%p %v \n", &x, x)
		return x + y
	}
}
// 0xc420082050 10
// 0xc420082050 10
// 11
// 0xc420082050 10
// 12

三次x的地址指向都是同一个x
```

>（1）闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；
>（2）网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；
>（3）尽量少学习。


## 接口
接口被定义为一组方法签名的集合。  
接口类型的值可以保存实现其方法的任意值。  

```go
package main

import "fmt"

type Printer interface {
	Name() string
	Print()
	Devicer
}

type Devicer interface {
	Start()
}

type HP_Printer struct {
	name string
}

type Sony_Printer struct {
	name string
}

//func (hp *HP_Printer) Start() {
func (hp HP_Printer) Start() {
	fmt.Println("hp start()")
}

// func (hp *HP_Printer) Name() string {
func (hp HP_Printer) Name() string {
	return hp.name
}

// func (hp *HP_Printer) Print() {
func (hp HP_Printer) Print() {
	fmt.Println("hp print():", hp.name)
}

func main() {
    // var hp Printer
	// hp = HP_Printer{"hp printer"}
	//hp := &HP_Printer{"hp printer"}
	hp := HP_Printer{"hp printer"}
	fmt.Println(hp.Name())
	hp.Print()

	stop(hp)
}

func stop(printer Printer) {
	fmt.Println("stop print")
}

// hp printer
// hp print(): hp printer
// stop print
```

## 接口嵌套

```go
package main

import "fmt"

type Printer interface {
	Name() string
	Print()
	Devicer
}

type Devicer interface {
	Start()
}

type HP_Printer struct {
	name string
}

type Sony_Printer struct {
	name string
}

//func (hp *HP_Printer) Start() {
func (hp HP_Printer) Start() {
	fmt.Println("hp start()")
}

// func (hp *HP_Printer) Name() string {
func (hp HP_Printer) Name() string {
	return hp.name
}

// func (hp *HP_Printer) Print() {
func (hp HP_Printer) Print() {
	fmt.Println("hp print():", hp.name)
}

func main() {
	// var hp Printer
	// hp = HP_Printer{"hp printer"}
	//hp := &HP_Printer{"hp printer"}
	hp := HP_Printer{"hp printer"}
	fmt.Println(hp.Name())
	hp.Print()

	stop(hp)
}

func stop(printer Printer) {
	fmt.Println("stop print")
}

```

```go
package main

import (
	"fmt"
)

type Printer interface {
	Name() string
	Print()
	Devicer
}

type Devicer interface {
	Start()
}

type HP_Printer struct {
	name string
}

type Sony_Printer struct {
	name string
}

func (sy Sony_Printer) Name() string {
	return sy.name
}

func (sy Sony_Printer) Print() {
	fmt.Println(sy.name, "printing...")
}

func (sy Sony_Printer) Start() {
	fmt.Println(sy.name, "start()")
}

func (hp HP_Printer) Start() {
	fmt.Println(hp.name, "start()")
}

func (hp HP_Printer) Name() string {
	return hp.name
}

func (hp HP_Printer) Print() {
	fmt.Println(hp.name, "printing...")
}

func main() {
	hp := HP_Printer{"hp printer"}
	hp.Start()
	hp.Print()
	stop(hp)

	sony := Sony_Printer{"sony printer"}
	sony.Start()
	sony.Print()
	stop(sony)

}

func stop(printer Printer) {
	if hp, ok := printer.(HP_Printer); ok { //类型断言
		fmt.Println(hp.name, "stop()")
		return
	}
	fmt.Print("Unknown printer.")
}

// hp printer start()
// hp printer printing...
// hp printer stop()
// sony printer start()
// sony printer printing...
// Unknown printer.
```
## 空接口
根据go语言接口的实现原理，我们可以得出结论go的所有类型的方法都实现了空接口。  

```go
type empty struct {}
```
前面的一个示例中的stop方法我们进行改造

```go
func stop(printer empty) {
	if hp, ok := printer.(HP_Printer); ok {
		fmt.Println(hp.name, "stop()")
		return
	}
	fmt.Print("Unknown printer.")
}
```
## switch type类型自推断
我们使用ok partner的方式只适用于少量的分支判断，但是如果想本例中传入的是广泛的空接口，这种想法将很麻烦。switch结构更加适合，
配合go的类型推断和`switch type`结构。     

```go
func stop(printer empty) {
	if hp, ok := printer.(HP_Printer); ok {
		fmt.Println(hp.name, "stop()")
		return
	}
	fmt.Print("Unknown printer.")

	switch v:=printer.(type) {
	case HP_Printer:
		fmt.Println(v.name,"stop()")
	default:
		fmt.Println("Unknown printer.")
	}
}
```

## 接口类型转换
遵循其他语言子集向上转换

```go
hp := HP_Printer{"hp printer"}
	fmt.Println(hp.name)
	p := Devicer(hp)
	p.Start()
```




```go
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f
	fmt.Println(a.Abs())
	a = v // cannot use v(type Vertex) as type Abser, Vertex dose not implement Abser(Abs method has pointer receiver)
	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```
示例代码将编译出错，`Vertex`(值类型)没有实现`Abser`，因为`Abs`方法仅仅定义了`*Vertex`(指针类型)。
解决方案是
`a = &v`或者 `v := &Vertex{3,4}`

## 接口与隐式实现
一个类型实现接口通过实现接口的方法。这里没有明确的声明意图，没有"implements"关键字。  

隐式接口从实现上解耦了接口的定义，也就是说实现可以出现在任意包中，无需提前准备。 实现上解耦接口的定义这就话可以对比其他语言，比如java的接口与实现，都是通过明确的关键字进行声明，而Go语言无需在每一个实现上增加新的接口名称，有利于鼓励明确的接口定义。

```go
package main

import (
	"fmt"
)

type I interface {
	M()
}

type T struct {
	S string
}

func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	i := T{"hello"}
	// var i I = T{"hello"}
	i.M()
}

```

## 接口值
在实现内部，接口值可以被看作包含值和具体类型的元组`(value, type)`
接口值保存了一个底层的具体类型的具体值。  
**接口值调用方法时会执行其底层类型的同名方法。**  

```go
package main

import (
	"fmt"
	"math"
)

type I interface {
	M()
}

type T struct {
	S string
}

type MyFloat float64

func (t *T) M() {
	fmt.Println(t.S)
}

func (f MyFloat) M() {
	fmt.Println(f)
}

func main() {
	var i I

	i = &T{"hello"}
	describe(i)
	i.M()

	i = MyFloat(math.Pi)
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v,%T)\n", i, i)
}

// (&{hello},*main.T)
// hello
// (3.141592653589793,main.MyFloat)
// 3.141592653589793
```


## 底层值为nil的接口值
如果接口中的实际具体值为`nil`，该方法仍将被一个`nil`类型的接收器调用。  
在其他一些语言中，这将导致空指针异常，但是在`Go`中通常使用`nil`接收器写个方法来有优雅地处理它。(例如下面的示例中`M`方法)  

保存了`nil`具体值的接口其本身并不是`nil`。  

```go
package main

import (
	"fmt"
)

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}

func main() {
	var i I
	var t *T
	i = t
	describe(i)
	i.M()

	i = &T{"hello"}
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}

// (<nil>, *main.T)
// <nil>
// (&{hello}, *main.T)
// hello
```

## nil接口值
nil接口值既不保存值也不保存具体的类型。  

nil接口调用方法是运行时错误，因为**接口的元组内并没有包含**能够指明调用哪个**具体**方法的**类型**

```go
package main

import (
	"fmt"
)

type T interface {
	M()
}

func main() {
	var t T
    describe(t)
	t.M()
}

func describe(t T) {
	fmt.Println("(%v, %T)\n",t,t)
}

/**
panic: runtime error: invalid memory address or nil pointer dereference
(<nil>, <nil>)
[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x1088b8a]

goroutine 1 [running]:
main.main()
	/Users/fqc/github/golang_sidepro/src/github.com/fqc/tour/go_tour.go:14 +0x3a
exit status 2
*/
```

## 空接口
没有一个方法的接口类型被认作为空接口。  
```go
interface{} //  a special type
```
空接口可以保存任意类型的值。(每种类型都实现了空接口，因为不用实现任何方法)

空接口通常用来处理未知类型的值。例如，`fmt.Print`接收任意数量的`interface{}`空接口类型。  

```go
package main

import (
	"fmt"
)

func main() {
	var i interface{}
	describe(i)

	i = 43
	describe(i)

	i = "hello"
	describe(i)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}

// (<nil>, <nil>)
// (43, int)
// (hello, string)
```

## 类型断言
类型断言提供了底层具体值的访问。  

```go
t := i.(T)
```
上述语句断言接口值`i`保存了具体类型`T`并将T的底层具体值赋予了变量`t`。  
如果`i`没有持有`T`,上述语句将异常(`trigger a panic 出发恐慌..异常`)

为了测试接口值是否持有特定的类型，类型断言可以返回两个值:
1. 底层值
2. 报告断言是否成功的布尔值
```go
t, ok := i.(T)
```
如果`i`持有`T`，则`t`将被赋予`i`的底层值，`ok`将为`true`。相反，`ok`则为false，`t`将为`T`类型的默认零值，但没有异常发生。  

注意此语法和读取map类似。  
```go
package main

import (
	"fmt"
)

func main() {
	var i interface{} = "hello"
	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string)
	fmt.Printf("%v, %v\n", s, ok)

	f, ok := i.(float64)
	fmt.Printf("%v, %v\n", f, ok)

	//f = i.(float64) // panic
	//fmt.Println(f)

	/**
	panic: interface conversion: interface {} is string, not float64

goroutine 1 [running]:
main.main()
	/Users/fqc/github/golang_sidepro/src/github.com/fqc/tour/go_tour.go:18 +0x3a7
exit status 2
	*/
}

// hello
// hello, true
// 0, false
```

## 反射

```go
package main

import (
	"reflect"
	"fmt"
)

type Student struct {
	Name string
	Age  int
	Sex  byte
}

func info(obj interface{})  {
	o := reflect.TypeOf(obj)
	fmt.Println("type:",o.Name())
	val:= reflect.ValueOf(obj)
	fmt.Println("value:",val)

	len := o.NumField()
	for i := 0; i < len; i++ {
		field := o.Field(i)
		value := val.Field(i).Interface()
		fmt.Printf("%8s: %v %v\n", field.Name,field.Type,value)
	}

}
func main() {
	s := Student{"kobe",24,1}
	info(s)
}

// type: Student
// value: {kobe 24 1}
//     Name: string kobe
//      Age: int 24
//      Sex: uint8 1
```

## 反射方法
```go
package main

import (
	"reflect"
	"fmt"
)

type Student struct {
	Name string
	Age  int
	Sex  byte
}

func (s Student) Say() {
	fmt.Println(s.Name)
}
func info(obj interface{}) {
	o := reflect.TypeOf(obj)
	fmt.Println("type:", o.Name())
	val := reflect.ValueOf(obj)
	fmt.Println("value:", val)

	len := o.NumField()
	for i := 0; i < len; i++ {
		field := o.Field(i)
		value := val.Field(i).Interface()
		fmt.Printf("%8s: %v %v\n", field.Name, field.Type, value)
	}

	for i := 0; i < o.NumMethod(); i++ {
		method := o.Method(i)
		fmt.Printf(" %v %v\n", method.Name, method.Type)
	}
}

func main() {
	s := Student{"kobe", 24, 1}
	info(s)
}

```
注意，本实例无法反射非struct，如果传入指针将会编译错误。我们可以通过判断反射后的类型来过滤非struct

```go
if k := o.Kind(); k != reflect.Struct {
	fmt.Println("non struct type")
	return
}
```


## 如何反射匿名或嵌套组合字段

```go
package main

import (
	"reflect"
	"fmt"
)

type Student struct {
	Name string
	Age  int
	Sex  byte
}

type Teacher struct {
	Student
	Class string
}

func (s Student) Say() {
	fmt.Println(s.Name)
}

func info(obj interface{}) {
	t := reflect.TypeOf(obj)
	fmt.Println(t.Field(0))
	fmt.Printf("%v\n", t.Field(0))
	fmt.Printf("%#v", t.Field(0))
}

func main() {
	teacher := Teacher{Student{"zhangsan", 20, 1}, "english"}
	info(teacher)
}

// {Student  main.Student  0 [0] true}
// {Student  main.Student  0 [0] true}
// reflect.StructField{Name:"Student", PkgPath:"", Type:(*reflect.rtype)(0x10a6020), Tag:"", Offset:0x0, Index:[]int{0}, Anonymous:true}
```
注意
1. 格式化字符串`%#v`，可以通过[官网fmt文档](https://golang.org/pkg/fmt/)查询到使用方法。
2. Anonymous:true 我们反射了匿名嵌套字段User，之所以为匿名字段，这里一目了然。
3. 匿名字段其实是只有类型的,其字段名称由于和类型一样，故省略，一般在嵌套组合字段中常用。  

```go
type A struct {
	Name string
	User User
	Teacher // 字段名称省略 Teacher Teacher
}
```
4. 如何获取嵌套类型的具体字段-- 使用FieldByIndex方法和切片

```go
fmt.Printf("%#v\n", t.FieldByIndex([]int{0,0}))
fmt.Printf("%#v\n", t.FieldByIndex([]int{0,1}))
fmt.Printf("%#v\n", t.FieldByIndex([]int{0,2}))

// reflect.StructField{Name:"Name", PkgPath:"", Type:(*reflect.rtype)(0x10979c0), Tag:"", Offset:0x0, Index:[]int{0}, Anonymous:false}
// reflect.StructField{Name:"Age", PkgPath:"", Type:(*reflect.rtype)(0x1097440), Tag:"", Offset:0x10, Index:[]int{1}, Anonymous:false}
// reflect.StructField{Name:"Sex", PkgPath:"", Type:(*reflect.rtype)(0x1097b40), Tag:"", Offset:0x18, Index:[]int{2}, Anonymous:false}
```

## 通过反射修改值
`reflect.ValueOf(i interface{})` 返回值为Value类型，需要取出其类型对应的底层值，我们传递指针，并且通过Elem()方法获取到底层对象，然后设置修改值。  

```go
x := 123
xx:= reflect.ValueOf(&x) // 返回类型为Value
//xx =192 // can not use 192(type untyped int) as type Value in assignment
xx.Elem().SetInt(192)
fmt.Printf("%v", x)
```

修改更为复杂的值
```go
package main

import (
	"reflect"
	"fmt"
)

type Student struct {
	Name string
	Age  int
	Sex  byte
}

type Teacher struct {
	Student
	Class string
}

func (s Student) Say() {
	fmt.Println(s.Name)
}

func main() {
	stu := Student{"kobe", 24, 1}
	Set(&stu)
	fmt.Println(stu)
}

func Set(o interface{}) {
	v := reflect.ValueOf(o)
	if v.Kind() == reflect.Ptr && !v.Elem().CanSet() {
		fmt.Printf("xxx")
		return
	}
	v = v.Elem()
	nameField := v.FieldByName("Name")
	if !nameField.IsValid() {
		fmt.Println("bad param")
		return
	}

	if nameField.Kind() == reflect.String {
		nameField.SetString("kobe24")
	}
}

```
## 反射方法进行调用

```go
package main

import "fmt"

type User struct {
	Name string
	Age int
	Sex byte
}

func (u User) SayHello(name string) {
	fmt.Println("hello",name,"my name is",u.Name)
}

func main() {
	u := User{"kobe",24,1}
	v := reflect.ValueOf(u)
	m := v.MethodByName("SayHello")
	args := []reflect.Value{reflect.ValueOf("james")}
	m.Call(args)
}
```


## 并发 concurrency
### 数据结构Channel
- Channel是Go程序(Goroutine)的一种高级数据结构。它可作为不同goroutine之间的桥梁即数据传输通道，在通道内传递的指定类型消息，我们将其称为通道的类型化数据(或类型元素)。  
- Channel定义
通过描述，我们自然能想到一个Channel的定义:  
`chan T`   
chan关键字代表通道 T代表通道内传递数据的类型  
- 在通道内消息的传递是安全的。  
- Goroutine代表Go并发程序，由go runtime运行时系统调度，依托于内核线程并发执行代码。  
- 通道的初始化
通道类型比较特殊，没有字面值，只能使用make函数初始化构造`值`。  

`make(chan int, 5)`   
第一个参数代表 元素类型为int的通道
第二个参数代表 通道的长度为5，实际代表缓存的长度为5
也就是说上面的通道创建含义为构建一个缓存大小为5，元素类型为int的`通道值`。  

注意:   
  这里着重强调了`值`的概念。当我们在编译的时候，单独声明`chan int`或`make(chan int, 5)`，编译器都无法编译通过。 尤其是在`make(chan int, 5)`编译提示 `make(chan int, 5), evaluated but not used`。这也印证了go的哲学，去除无用。

通道中缓存即通道暂存的数据为先进先出结构，针对于通道值而言，越早被放入(发送)到通道的元素越早被放出通道(接收)。  
`send -> channel -> receiver`     

- `<-`
符号`<-`为向通道中发送(write/send)或接收(read/receive)数据

声明一个通道并向该通道发送值，然后从该通道中取出值。  

```go
ch := make(chan int, 1)
ch <- 99
fmt.Println(<-ch) // 99
```

读取通道值可以返回两个值，`val`代表读取的通道元素值，`ok`代表通道的状态。

```go
ch := make(chan int, 1)
ch <- 99
val, ok := <-ch
if !ok {
	fmt.Println("channel has been closed")
	return
}
fmt.Println(val)
```

第二参数`ok`为bool类型，代表通道值是否有效或通道已关闭。在接收之前或过程中，通道值被关闭了，接收或写操作立即结束并返回一个通道元素类型的零值(这里通道元素类型为int，因此零值则为0)，那么零值容易混淆，我们并不知道0是否正常返回，因此有了第二个布尔返回值代表通道值的状态，我们对于判断就心里有底了。  

关闭通道可以通过程序自动终止或者通过内置函数`close(c chan <- Type)`手动关闭。

关于channel的几点注意事项:
- 通道有效的前提下，直至通道被填充满会阻塞(被放入缓存的数据等于通道长度)，否则都为异步
- 有效通道，接收通道值会在其已空时(没有缓存数据)阻塞
- 在向关闭的通道发送数据将会引起恐慌
- 重复关闭通道会引起恐慌
- 通道类型为引用类型，零值为nil

```go
package main

import "fmt"

func main() {
	ch := make(chan int)
	ch <- 99 //非缓冲通道，发送数据会被阻塞，下面的取数据则造成死锁
	val, ok := <-ch // 接收方会一直等到有数据来
	if !ok {
		fmt.Println("channel has been closed")
		return
	}
	fmt.Println(val)
}
// fatal error: all goroutines are asleep - deadlock!
//
// goroutine 1 [chan send]:
// main.main()
// 	/Users/fqc/work/src/run.go:7 +0x7a
```

```go
package main

import "fmt"

func main() {
	ch := make(chan int,1)
	ch <- 99 //带缓存的通道，直至缓存填满为同步，否则为异步
	val, ok := <-ch // 接收方可以随时取数据，直至缓存数据为空时阻塞
	if !ok {
		fmt.Println("channel has been closed")
		return
	}
	fmt.Println(val)
}
```

总结:  
非缓存通道，发送方在向通道值发送数据的时候会立即阻塞，直到接收方来消费数据。 `make(chan T, n)`，其中n>0
缓存通道，发送方会立即拷贝数据到缓存直到等于缓存长度进入阻塞，接收方可随时取数据，直到缓存数据为空时阻塞。 `make(chan T,0)`，其中n=0

## 单向通道与多项通道  
除了按照有无缓存划分通道的种类，还可以通过通道的方向划分为单向通道和双向通道，而双向通道是默认的。  
单向通道即数据只能按照一个方向进行传输，按照发送者和接受者的数据流方向的不同，可以分为接收通道和发送通道。  
```go
type Sender chan<- int // 发送者通道
type Receiver <-chan int // 接受者通道
```
注意
1. 发送者通道 `chan<-` 箭头**指向**通道
2. 接受者通道 `<-chan` 箭头**来自**通道
类型Receiver,Sender代表接收/发送通道类型，chan关键字后跟随的箭头符号代表了数据的流向

###
```go
package main
import (
	"fmt"
	"time"
)

func main() {
	go Run()
	time.Sleep(2 * time.Second)
}

func Run() {
	fmt.Println("go concurrency")
}
```

使用匿名函数
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go func() {
		fmt.Println("hello concurrency")
	}()
	time.Sleep(2 * time.Second)
}

func Run() {
	fmt.Println("go concurrency")
}
```

### 更优雅的通信，而非不靠谱的线程睡眠
Go可以使用通信机制解决共享内存带来的苦恼。    
- Channel是goroutine通信的桥梁，大都是阻塞同步的   
- 使用make创建，close关闭
- 可使用for range 对Channel进行迭代不断操作
- 引用类型
- 可以设置缓存大小，未填满前不会阻塞
- 可以设置单向、双向通道

channel读消息会阻塞同步的，直到通道中有消息写入，channel读取到才会继续执行。  

```go
package main

import "fmt"

func main() {
	c := make(chan bool)
	go func() {
		fmt.Println("goroutine")
		c <- true // 存 发送消息
	}()
	<-c //取 接收消息 main执行到这里会阻塞，直到匿名函数中存入了true，channel读取到才会继续执行。
}

```

迭代chaanel时需要明确的正确的执行关闭了channel，否则会造成死锁
```go
package main

import "fmt"

func main() {
	c := make(chan bool)
	go func() {
		fmt.Println("goroutine")
		c <- true
		close(c)
	}()
	for val := range c {
		fmt.Println(val)
	}
}

// goroutine
// true
```

没有正确关闭channel导致死锁

```go
...
//close(c)
...

// fatal error: all goroutines are asleep - deadlock!
// goroutine
//
// true
// goroutine 1 [chan receive]:
// main.main()
// 	/Users/fqc/work/src/run.go:12 +0x85
```

使用make函数都是双向通道channel，可存可取
单向通道，只能存或取，一般用在参数传递上，目的在于防止误读误写操作。  

未设置缓存大小时，缓存为零值，那么它将是阻塞同步的。设置缓存而没有存满的时候该通道为异步的，不会发生阻塞。  
有缓存和无缓存的区别  

```go
package main

import "fmt"

func main() {
	c := make(chan bool)
	go func() {
		fmt.Println("goroutine")
		<-c
	}()
	c <- true
}
// goroutine
```

`c := make(chan bool, 1)`  
将不会输出。   
```go
c := make(chan bool)
go func() {
	fmt.Println("goroutine")
	<-c
}()
c <- true // 无缓存的时候是阻塞的，里面的内容需要被写完或消息被发送完。因此有缓存的时候还可以被写入
```

有缓存的时候，异步，都会向下执行
诀窍:首先认为是瀑布执行，然后分析关键点 1.看读写顺序 2.看有无缓存
阻塞或异步的时候，读始终需要让写先执行
阻塞的时候，读取的时候需要有消息，否则一直阻塞
异步的时候，读更快嘛...
有缓存的时候爱读不读，没缓存的时候需要等待写入玩 读出来，这和实际开发中联系 缓存可以不去读，但无缓存需要强制去读
有缓存是异步的，无缓存是同步阻塞的。

如何让有缓存的时候，也想让其同步，该如何实现?

































## 附录

https://godoc.org/golang.org/x/tools/cmd/guru
https://docs.google.com/document/d/1_Y9xCEMj5S-7rv2ooHpZNH15JgRT5iM742gJkw5LtmQ/edit#

```sh
Setting up

Download and build the guru tool and install it somewhere on your $PATH.

$ go get   golang.org/x/tools/cmd/guru
$ go build golang.org/x/tools/cmd/guru
$ mv guru $(go env GOROOT)/bin                   (for example)
$ guru -help
Go source code guru.
Usage: guru [flags] <mode> <position>
...

```


describe        describe selected syntax: definition, methods, etc

























## Tips
```go
go tool tour // 英文go tour  
$GOPATH/bin/gotour // 中文go tour  ```


