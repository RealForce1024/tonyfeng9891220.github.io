---
layout: post
title: 003-Go基础之一 包、变量、函数
category: golang架构师之路
tags: golang,tour,function,variables,package
keywords: package,tour,function,variables
---

## Go官方编程指南交互工具 tour
在安装好go环境之后，我们可以运行一个神奇的命令浏览器自动打开并跳转到Go官方提供的编程指南(本地服务，可以避免一些你懂的网络故障..)

```sh
$ go tool tour
[master|●2✚1…
23:38:05 Serving content from /usr/local/go/misc/tour
23:38:05 A browser window should open. If not, please visit http://127.0.0.1:3999
23:38:06 accepting connection from: 127.0.0.1:58925
```
也可以后台运行

```sh
$ nohup go tool tour & tour.log                                                                                                                               [master|●2✚1…
[1] 48104
appending output to nohup.out
zsh: command not found: tour.log

cat nohup.out                                                                                                                                               [master|●2✚1…
 23:49:30 Serving content from /usr/local/go/misc/tour
 23:49:30 A browser window should open. If not, please visit http://127.0.0.1:3999
 23:49:31 accepting connection from: 127.0.0.1:59131
 23:50:14 accepting connection from: 127.0.0.1:59142
 23:50:16 accepting connection from: 127.0.0.1:59143
 23:50:19 accepting connection from: 127.0.0.1:59144
 23:52:46 Serving content from /usr/local/go/misc/tour
 23:52:46 A browser window should open. If not, please visit http://127.0.0.1:3999
 23:52:47 accepting connection from: 127.0.0.1:59173
```

## 基本结构

```go
package main

import "fmt"

var name = "gopher"

const PI = 3.14

var newType int

type gopher struct {}

type golang interface {}

func main() {
	fmt.Println("hello world! 你好，世界！")
}
```

## 命名
go的变量命名一般推荐驼峰命名，优先采用较短命名，不过这取决于变量的生命周期，生命周期长，作用范围大的变量名称越详细越好。  
而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法,它们可能被称为 htmlEscape、HTMLEscape或escapeHTML,但不会是escapeHtml。

可以覆盖内置函数，但是要慎重。但这个在团队开发中，严厉禁止！  

## 变量
变量是对应类型的内存空间，而指针则是该变量在内存中的存储位置(地址)。  

`var a string` //默认零值 ""

声明的方式

```go
var a string = "hello go"
var b = "world"
c := "world"
var x,y,z int = 0,1,2
var m,n = 10,11
e,f := 3,4
file,err := os.Open("/usr/local/a.txt") //函数返回值初始化一组变量！

fmt.Println(a,b,c,x,y,z,m,n,e,f,file,err)

//hello go world world 0 1 2 10 11 3 4 <nil> open /usr/local/a.txt: no such file or directory
```

总结:最简单的方式像排队领号码一样。 然后每人可以加上类型，再加上var装饰，不加var装饰的需要`:=`。

## 变量

- `var`语句块定义一些列的变量
- 像在函数参数列表一样的方式，类型声明在最后
- `var`语句块可以为包或函数级别。

示例:  

```go
var c, java, python bool

func main() {
	var i int
	fmt.Println(i, c, java, python)
    //0 false false false
}
```

### 变量初始化器
- 变量声明定义可以包含一个初始值，每个变量一个。  
- 如果已经存在初始值，则可以省略类型，变量将采用初始值的类型。

```go
var i, j int = 1, 2

func main() {
    var c, java, python = true, false, "no!" // 使用初始值的类型
    fmt.Println(i, j, c, java, python)
}
```

### 短声明变量初始化
- 在函数中，`:=`简洁赋值(短赋值块)可以使用于代替`var`定义。(隐藏着隐式类型的概念，也就是**通过表达式的右边值或变量的类型进行类型推断而获得类型**)  
- 在函数外，每个语句都必须以关键词开始(`var,func`等等)，所以<font color='red'>**`:=`结构是不可以在函数外使用的**</font>  

```go
func main() {
	var i, j int = 1, 2
	k := 3
	c, java, python := 100, 100, 100
	fmt.Println(i, j, k, c, java, python)
}
```
- 并行赋值或(同时赋值)  
`a, b := 1, 2`    

- 交换技巧  
`a, b = b, a` 利用go语言的并行赋值，可以比其他语言方便的进行变量值交换，而无需使用交换函数。

- 用于多个返回值  
`val, err := Func1(var1)`  

### `_`空白标志符
`_`空白标识符被用于抛弃值，`_`实际上是一个只写变量，你不能得到它的值。由于go要求无多余代码，也就是必须使用所有被声明的变量，但有时我们并不需要使用从一个函数中得到所有返回值。

`_, b = 5, 7` ，5被抛弃。

`import _ "github.com/golang..."`
引入该包，但不直接使用该包的函数，而是调用该包的init函数
### 变量的作用域

变量的生命周期或作用域只取决于**是否可达**。超出作用域则无效，而局部变量在函数返回时依然存在。  
**编译器会自动选择在栈上还是在堆上分配局部变量的存储空间,但可能令人惊讶的是,这个选择并不是由用var还是new声明变量的方式决定的。**

```go
var global *int

func x() {
	var b int = 1
	global = &b
}

func y() {
	m := new(int)
	*m = 1
}
```

变量b是必须分配在堆上，在函数退出后，依然可以通过global变量找到b变量。从Go语言的术语中，**局部变量b从x函数中逃逸了**。  
而变量m虽然用new创建，但是y函数结束后,***m并未从y函数中逃逸，编译器会首选在栈上分配**。  

如果将指向短生命周期对象的指针保存到具有长生命周期的对象中, 特别是保存到全局变量时,会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能)。例如x函数中的b变量保存到了全局global变量中。  

注意:**不要将作用域和生命周期混为一谈。**   

- 声明语句的作用域对应的是一个源代码的文本区域;它是一个编译时的属性。
- 一个变量的生命周期是指程序运行时变量存在的有效时间段,在此时间区域内它可以被程序的其他部分引用;是一个运行时的概念。


## 函数值

```go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```
squares的例子证明，**函数值不仅仅是一串代码，还记录了状态**。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着**匿名函数和squares中，存在变量引用**。这就是**函数值属于引用类型**和函数值不可比较的原因。**Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。**

变量的生命周期不由它的作用域决定(闭包):square闭包函数返回后,变量x仍然隐式的存在于f中。

但是需要注意一定要获取到函数值的引用，否则只是相同的值而已。因为只有获得闭包返回变量后才能获得匿名函数的隐式变量。  

```go
func main() {
	fmt.Println(square()())
	fmt.Println(square()())
	fmt.Println(square()())
	fmt.Println(square()())
	fmt.Println("-------")
	f:= square()
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
}

func square() func() int {
	var x int
	return func() int {
		x++
		return x * x
	}
}
```

## 包与导入路径

- 每个Go程序都是由包组织成
- 程序入口在`main`包下
- 该示例程序`导入`了`fmt`和`math/rand`两个`路径`。
- 根据Go语言的惯例，**`包名和导入路径的最后一个元素相同`**。例如，"math/rand"包含在一个以`package rand`开头的文件。(**注意:导入路径为"math/rand"，但包名为"rand"**)
- 别名 `fm "fmt"`  
- 包名和包所在的文件夹名可以是不同的

```go
package main

import(
    "fmt"
    "math/rand"
)

func main(){
    fmt.Println("My favorite number is",rand.Intn(10))
}
```

### 导入(import statement)

- 导入语句中使用了`()`打包多个导入路径，可以认为是"打包"导入方式，其实也可以分别导入(不推荐)，例如:

```go
package main

// import "fmt"
// import "math"

import (
	"fmt"
	"math"
)

func main() {
    fmt.Println("Now you have %g problems.", math.Sqrt(7))
}
```

### 导入别名

格式 `import alias_name "package_name"`  
例如: `import fm "fmt"`  

```go
package main

import (
	my_pkg "pkg01/sub_pkg"
	"fmt"
)

func main() {
	reverse_str := my_pkg.Reverse("!olleh")
	fmt.Printf("%v", reverse_str)
}

```

```sh
☁  pkg01  tree
.
├── sub_pkg
│   └── mystring.go
└── test.go

1 directory, 2 files
```
### 本地导入(类似Java的静态导入)
```go
package main

import (
	. "strings"
	"fmt"
)

func main() {
	fmt.Println(HasPrefix("kobe","k"))
	fmt.Println(HasPrefix("kobe","b"))
}
```

### 导入初始化

导入初始化一般是导入父类或容器的配置，预加载，初始化等重操作或者框架的默认导入操作。使用场景比如`导入数据库驱动`等等。由于golang对于未使用的导入不会被编译通过，所以需要使用`_`操作符通知编译器。

```go
package main

import (
    // "strings"  编译错误
	_ "strings"
)

func main() {
}
```

### 代码包初始化

```go
package main

import "fmt"

func init() {
	fmt.Println("init")
}
func main() {
	fmt.Println("main")
}

```
注意：**init函数的执行时机尽量不要假设，除非知道依赖顺序**，所以最好是有个统一的地方包裹初始化操作。  


## go doc

使用方式: 

- `go doc package`
- `go doc package/subpackage`
- `go doc package function`
- `godoc -http=:6060` 打开本地go官方的文档(注意不要搞反了 不是`:=Port` 而是 `=:Port`)

`go doc`命令行
`godoc`则是server服务，不仅仅官方文档的说明，只要是gopath中的库包都会有。

```sh
☁  ~  go doc pkg01/sub_pkg Reverse
func Reverse(s string) string

☁  ~  go doc pkg01/sub_pkg
package sub_pkg // import "pkg01/sub_pkg"

Reverse string

func Reverse(s string) string
```
### 随机函数的案例
我们也可以看到注释生成文档的方式，在函数上方，以函数名开头`Method do what`的方式。

```go
☁  aws  go doc math/rand New
func New(src Source) *Rand
    New returns a new Rand that uses random values from src to generate other
    random values.
```

```sh
func main() {
	//randN := rand.New(rand.NewSource(100)) 这种方式是没有效果的，需要有个变化的种子
	randN := rand.New(rand.NewSource(time.Now().UnixNano()))//给一个时间戳值
	for i := 0; i < 1000; i++ {
		if a := randN.Intn(1000); a < 10 {
			fmt.Println(a)
		}
	}
}
```

注意：**这个程序的运行环境是固定的，因此 rand.Intn 总是会返回相同的数字,甚至在一组连续的输出连顺序都是一样的**。 （**为了得到不同的数字，需要生成不同的种子数**，参阅 rand.Seed。）

```go
$: go doc math/rand
package rand // import "math/rand"

Package rand implements pseudo-random number generators.

Random numbers are generated by a Source. Top-level functions, such as
Float64 and Int, use a default shared Source that produces a deterministic
sequence of values each time a program is run. Use the Seed function to
initialize the default Source if different behavior is required for each
run. The default Source is safe for concurrent use by multiple goroutines.

For random numbers suitable for security-sensitive work, see the crypto/rand
package.


func Float64() float64
func Int() int
func Int31() int32
func Int31n(n int32) int32
func Int63() int64
func Read(p []byte) (n int, err error)
func Seed(seed int64)
func Uint32() uint32
func Uint64() uint64
type Rand struct{ ... }
    func New(src Source) *Rand
type Source interface{ ... }
    func NewSource(seed int64) Source
type Source64 interface{ ... }
type Zipf struct{ ... }
    func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf
```

```go
// rand.Seed(19990)固定种子，每次的结果都是一样
r := rand.New(rand.NewSource(time.Now().UnixNano())) // 时间序列种子
fmt.Println(r.Intn(1000)) // 0~1000中取随机数
```

我们可以观察到New函数和NewSource函数

```go
// A Rand is a source of random numbers.
type Rand struct {
	src Source
	s64 Source64 // non-nil if src is source64

	// readVal contains remainder of 63-bit integer used for bytes
	// generation during most recent Read call.
	// It is saved so next Read call can start where the previous
	// one finished.
	readVal int64
	// readPos indicates the number of low-order bytes of readVal
	// that are still valid.
	readPos int8
}

// New returns a new Rand that uses random values from src
// to generate other random values.
func New(src Source) *Rand {
	s64, _ := src.(Source64)
	return &Rand{src: src, s64: s64}
}
```
## 类型
### 基本类型

Go的基本类型如下:

```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point(Unicode码)

float32 float64

complex64 complex128
```
注意byte和rune都是别名类型。  
示例展示了几个类型变量，变量声明也可以"打包"到`var ()`中类似`import()`导入块

```go
func main() {
        var (
            ToBe   bool       = false
            MaxInt uint64     = 1<<64 - 1
            z      complex128 = cmplx.Sqrt(-5 + 12i)
        )
	fmt.Printf("Type: %T, Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T, Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T, Value: %v\n", z, z)
}
//Type: bool, Value: false
//Type: uint64, Value: 18446744073709551615
//Type: complex128, Value: (2+3i)
```
`int`,`uint`,`uintptr`类型通常在32位系统是32位，64位系统是64位。当你需要使用整型值的时候应该首先使用`int`类型，除非你有特殊的原因使用一个有大小的或无符号的整形。  

### 命名的类型(类型声明或类型的别名)  

一个类型声明语句创建了一个新的类型名称,和现有类型具有相同的底层结构。新命名的类型提供了一个方法,用来分隔不同概念的类型,这样即使它们底层类型相同也是不兼容的。

只有当两个类型的底层基础类型相同时,才允许这种转型操作,或者是两者都是指向相同底层结构的指针类型,这些转换只改变类型而不会影响值本身。Celsius(T),Fahrenheit(T) 。
但注意数值类型的类型转换可能会改变值(一般表现为精度的缺失)

```go
type typeName underlyingType

type Celsius float64 // 摄氏温度

type Fahrenheit float64 // 华氏温度

var c Celsius
var f Fahrenheit
```
命名类型除了提供简单的类型名称，还会为该类型的值定义新的行为，即为该类型提供方法。将类型参数放到方法名称的前面，表示为该类型的xx方法。  

```go
func (c Celsius) String() string {
	return fmt.Sprintf("%g°C",c)
}
```

### 类型转换
表达式`T(v)`将值`v`转换为`T`类型。  
一些数值型转换:

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

或者简写：

```go
i := 42
f := float64(i)
u := uint(f)
```

和C不一样，Go的分配赋值在不同类型之间需要显示转换。试试移除`float64`或`uint`在例子中的转换(注意是非简写的例子尝试)，看会发生什么。

```go
var o int = 56
var p float64 = o //Cannot use o(int) as float64 in assignment
var q uint = uint(p)

o := 55 // no new variables on left side of :=
//p := o
//q := uint(p)
fmt.Printf("%v,%v,%v", o, p, q)
```

在例如:

```go
func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt((x*x + y*y))//Cannot use (x*x+y*y)(type int) as float64 in assignment
	var z uint = uint(f)

	fmt.Println(x, y, z)

}
```

### 类型推断
当声明变量但没有明确指定其类型时(不论是使用`:=`还是`var =`表达式语法)，变量类型将从表达式的右边的值进行类型推断。
当表达式右边是已经声明过变量类型，新的变量则会和右边类型相同。例如:
```go
var i string
j := i // j的类型为string
fmt.Printf("%q,%q\n", i,j)
```
但是当表达式右边为没有指明类型的数字常量时，新的变量则可能为`int`、`float`、`complex128`进行推断，这就取决于常量的精度。
```go
i := 42 // int
f := 3.14 // float64
g := 0.876 + 0.5i // complex128
```

```go
func main() {
	v := 4322
	fmt.Printf("v is type of %T\n", v)
	x := float64(v)
	fmt.Printf("x is type of %T", x)
}

// v is type of int
// x is type of float64
```

### 相同类型才能匹配比较

```go
package main

func main() {
	a := int32(5)
	b := int64(5)
	if a==b { // 编译错误，需类型相同。如果是类型是接口，必须实现相同的接口
		print(true)
	}
}

```

## 字符串
### 字符串表示

```go
package main

import (
    "fmt"
)

func main() {
    var str1 string = "\\\""

    fmt.Printf("用解释型字符串表示法表示的 %q 所代表的是 %s。\n", str1, `\`)
}
```
字符串表示有两种方式

1. 原生表示法
2. 解释型表示法
后者回车符等特殊符号会被转义。   

### 原生字符串面值

```go
const a = `
		hello world
		jkjkjkj      jkjkjkjkjdksjf                kljlj\\n
		\r\n
		helllo
	`
fmt.Printf("%v", a)

/*
		hello world
		jkjkjkj      jkjkjkjkjdksjf                kljlj\\n
		\r\n
		helllo
*/
```

### 字符串的长度

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "hello, 世界"
	fmt.Printf("%d\n", len(s))
	fmt.Printf("%d\n", utf8.RuneCountInString(s))

	for i, value := range s {
		fmt.Printf("%d\t%q\t%d\n", i, value,value) //%q
		//fmt.Printf("%d\t%s\t%d\n", i, value,value)
	}
}
// 13
// 9
// 0	'h'	104
// 1	'e'	101
// 2	'l'	108
// 3	'l'	108
// 4	'o'	111
// 5	','	44
// 6	' '	32
// 7	'世'	19990
// 10	'界'	30028
```

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	s := "hello, 世界"
	for i := 0; i < len(s); {
		r, size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n", i, r)
		i+=size // 步长是字符的size
	}
}

```

```go
package main

import (
	"fmt"
)

func main() {
	s := "hello, 世界"

	for i, val := range s { //val为int32类型 即rune
		fmt.Printf("%d\t%q\t%d%[2]T\n", i, val, val)
	}

	b := "hello"
	for _,v := range b { // int32并未自动降级int8
		fmt.Printf("%v\t%[1]T\n", v)
	}
}
```

### `+`连接字符串 

```go
fmt.Println("hello"+"world")
```

### `join`串联字符串

```go
fmt.Println(strings.Join([]string{"hello", "world", "中国"}, "-"))
```

```go
package main

import (
	"fmt"
)

func main() {
	/*s := "hello, 世界"
	n := 0
	for _,_ := range s { // no new variables on left side of :=
		n++
	}*/

	n := 0
	for _, _ = range "hello, 世界" {
		n++
	}

	fmt.Printf("%v\n", n)

	count := 0
	for range "hello, 中国" {
		count++
	}
	fmt.Printf("%v\n", count)
}

```
### 转换为字符串
string()将数据转换为文本格式。计算机中存储的任何东西本质都是数字0,1。因此自然将65转为对应的文本A。

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var a int = 65
	b := string(a)
	fmt.Printf("%v\n", b)

	var c int = 65
	d := strconv.Itoa(c)
	fmt.Printf("%v\n", d)

	f, _ := strconv.Atoi(d)
	fmt.Printf("%v", f)
}
```

### 不能修改的字符串该如何修改
字符串一旦定义不能修改，否则将无法编译通过。

```go
var s string = "hello"
s[0] = "e" //compile error
```

不过可以曲线救国，赋值给string底层类型byte[]
string和byte[]可以互转
```go
var s string = "hello"
var c []byte
//c = s[:] 注意s[:]为string类型  string[n]为byte类型
c = []byte(s)
c[0] = 'e'
s = string(c) // []byte和s是可以互转的
fmt.Printf("%v", s)
```

但是byte不能存储汉字等字符

```go
var s string = "hello 中国"
var c []byte
//c = s[:] 注意s[:]为string类型  string[n]为byte类型
c = []byte(s)
c[0] = 'e'
s = string(c) // []byte和s是可以互转的
fmt.Printf("%v\n", s)

//c[6] = '美' //注意 byte alias as int8 无法存储汉字 constant 32654 overflows byte
//var b byte = '美'
//fmt.Printf("%v\n", b)
var r rune = '美'
fmt.Printf("%v\t%[1]q\n", r)

var runes []rune
runes = []rune(s)
//runes[6] = "美"
runes[6] = '美'
s = string(runes)
fmt.Printf("%v\n", s)
```


## 默认值
变量声明时没有给予特定的初始值时，Go会给予默认值(Zero value)。有人也翻译称作为"零值"。

默认值有以下几种:
* 数值型 `0`
* 布尔型 `false`
* 字符型 `""`(空字符串)

```go
func main() {
    var i int
	var f string
	var b bool
	var s float64
	//fmt.Printf(i, f, b, s)//can not use i(int) as string
	fmt.Printf("%v,%q,%v,%v\n", i, f, b, s)
	fmt.Printf("%v,%v,%v,%v\n", i, f, b, s)
        //0,"",false,0 注意这里%q对于字符型值的作用
        //0,,false,0
}
```


## 常量
- 常量声明很像变量，只不过需要使用`const`关键字修饰
- 常量可以使字符，字符串，布尔或数值型
- 常量不能使用`:=`声明
- 常量的值必须在编译期就能够确定!!! 可以在赋值表达式中涉及计算过程，但是所有用于计算的值需要在编译期就能获得。比如`const c1=1/2` ok,但`const c2 = getNumber()`自定义函数在编译期无法获得具体值，因此无法用于常量的赋值。 但内置函数是可以的`len()`。    
常量是定义在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。
```go
package main

import "fmt"

var a string = "hello"

// const a = "hello"
const (
	b = len(a) // 编译错误
	c
)

func main() {

}
```
- 等号右边必须是常量或常量表达式，注意是常量表达式，一般的变量也是编译不通过的
- 常量表达式必须是内置函数
- 反斜杠`\`可以在常量表达式中作为多行的连接符使用。  
- 常量用作枚举
```go
const (
	UNKNOW = 0
	MALE = 1
	FEMALE = 2
)
```

```go
const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```

和var()`打包`声明类似，const也可以。  

```go
package main

import (
	"fmt"
)

const (
	A int    = 10
	B string = "ss"
)

func main() {
	fmt.Println(A, B)
}
```

## 常量的初始化规则
- 定义常量组时，如果不给初始值，则表示使用上行表达式。  
```go
package main

import "fmt"

const (
	a = 1
	b = 2
	c
	d
)

func main() {
	fmt.Printf("%v,%v,%v,%v", a, b, c, d)
}
// 1,2,2,2
```

- 每一行声明的变量的个数需要一致

```go
package main

import "fmt"

const (
	a, b = 1, "2"
	//c  编译不通过，需要每一行的变量个数相同
	//c //extra expression in const declaration
	c, d //1, 2
)

func main() {
	fmt.Printf("%v, %v", c, d)
}
```

## iota

iota是常量的计数器，从0开始，组中每定义一行(非一个)常量都会自动加1

```go
package main

import "fmt"

const (
	a = iota
	b = iota
	c = iota
)

func main() {
	fmt.Printf("%v,%v,%v", a, b, c)
}
// 0,1,2
```

```go
package main

import "fmt"

func main() {
	const(
		a,b = iota,iota
		//c  compile error
		c,d
		e,f
	)

	fmt.Println(c,d,e,f)
}

// 1 1 2 2
```


```go
package main

import "fmt"

func main() {
	const(
		a,b = iota,iota
		c = iota
	)

	fmt.Println(a,b,c)
}
```

- iota在**新的一行**都会自动加1。有了这个规则，就可以简写为

```go
const(
	a = iota
	b
	c
)

const(
	x = iota + 100
	y
	z
)
// 100,101,102
```

使用类型作为常量的枚举值
通过初始化规则与iota可以达到枚举的效果  

```go
type size int // 定义size类型 也是int别名(底层类型为int)

const (
	small size = iota
	middle
	max
)
```

注意:一般情况常量名称最好全大写，但是由于go包的可见性规则，**我们有时只希望自己包中使用，则可以采用
_下划线或cConstName的方式取巧避免与规则冲突。**

- 每遇到一个const，iota就会重置为0

```go
package main

import "fmt"

const (
	a, b = iota, iota //0 0
	c, d //1 1
	e, f // 2 2
)

const aa = iota // 0

func main() {
	fmt.Printf("%v, %v,%v, %v\n", c, d, e, f)
	fmt.Println(aa)
}

```

### 常量iota的值与之定义的顺序有关系，和出现的次数并无关系。

```go
const (
	a, b = iota, iota //0 0
	c, d //1 1
	e, f // 2 2
)
```

```go
package main

import "fmt"

const (
	a = "A"
	b
	c = iota
	d
)

func main() {
	fmt.Printf("%v, %v, %v, %v", a, b, c, d)
}
// A A 2 3
```

```go
package main

import "fmt"

const (
	a = "A"
	b = iota
	c = "B"
	d = iota
)

func main() {
	fmt.Printf("%v, %v, %v, %v", a, b, c, d)

}
// A 1 B 3
```

```go
package main

import "fmt"

func main() {
	const (
		a = 1
		b
		c = iota
		d
		e = 10
		f
		g = iota
		h
	)

	fmt.Printf("a=%d,b=%d\n", a, b)
	fmt.Printf("c=%d,d=%d\n", c, d)
	fmt.Printf("e=%d,f=%d\n", e, f)
	fmt.Printf("g=%d,h=%d\n", g, h)
}

// a=1,b=1
// c=2,d=3
// e=10,f=10
// g=6,h=7
```


## 数值型常量  

- 数值型常量是高精度的值。  
- 未指定类型的常量类型取决于上下文
- int可以最大可存储64位整数，有时可能少些取决于系统平台

```go
const (
	Big   = 1 << 100
	Small = Big >> 99
)

func needInt(x int) int {
    return x*10 + 1
}

func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
```

## 公开的字段
在Go语言里**首字母大写的字段是公开的**
注意这个约定非常重要，在很多框架或库包调用中由此会有很多可见性，函数是否触发，表单是否填充值的特性，都和该条约定或规则有关。

例如，在`math`包中的`Pi`就是公开的可以被外部包访问的。

`pizza`和`pi`首字母非大写，所有他们为私有的，外部访问是会报错的。

当导入包时你只能引用它的公开字段名称，任何一个`unexported`的名称或字段都不能被外部包所访问。 比如下面的示例，直接运行将会报错:
```go
package main

import "math"

func main() {
    func.Println(math.pi)//应该为Pi
}
```

报错如下:

```go
$ go run tour-pacakge.go
 # command-line-arguments
./tour-pacakge.go:12: cannot refer to unexported name math.pi
./tour-pacakge.go:12: undefined: math.pi
```

将`math.pi`修改为`math.Pi`即可正确运行。

```sh
$ go run tour-package.go
3.141592653589793
```

## 函数

1. 函数可以带有0或多个参数。下面的示例中,`add`函数包含两个`int`类型的参数。

```go
package main

import "fmt"

func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(40, 60))
}
```

注意**类型在变量的后面**。
可以参考Go的作者之一Rob Pike写的文章[《Go的声明语法》](https://blog.go-zh.org/gos-declaration-syntax)解释为什么使用这种类型声明在后,字段名称在前的方式。
通过阅读，其实最大的好处是在函数式编程中，go语法更便于阅读，将类型放后，函数名中间，func声明在前。

2. 当两个或更多连续的函数参数是同一种类型时，可以省略类型除了最后一个参数。  
例如:
可以将`x int, y int` 简写为`x, y int`

`1.`中的`add`函数参数可以简写为以下:

```go
func add(x, y int) int {
    return x + y
}
```

### 多个返回值
Go函数可以有多个返回值。下面的`swap`函数返回两个字符串

```go
package main

import "fmt" // gogland(IDE) 键入词imp 当使用包组织方式而只有一个包路径时，删除后是可以自动补全包路径的，很智能

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```

参数是传递变量副本。不论是值的副本还是指针地址，都变量副本。值的拷贝。当然在指针地址的拷贝传递后盖板会影响到原变量，因为指针指向是原变量。后面会更深刻的阐述。

```go
a, b := "hello", "world"
m, n := swap(a, b)
fmt.Println(a, b) //a,b的值并未交换
fmt.Println(m, n) //返回值变量是a,b变量副本的交换后的值
```


### 命名返回值(naked return)
Go的返回值是可以命名的，它们将被当做变量声明在方法的签名上。

返回值的名称通常被用在标记返回值的含义上。

没有带参数的`return`语句块返回被命名的返回值。这被称作是"赤裸裸的"回报("naked" return)...即"裸"返回或者直接返回语句。  

直接返回语句仅应该用在短函数中，例如下面的示例。但注意:命名返回值用在内容较长的函数中影响可读性。

```go
package main

import "fmt"

func add(x int, y int) (result int) {
	result = x + y
	return
}
func main() {
	fmt.Println(add(2,1))
}
```

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return //naked return
}

func main() {
	x, y := split(99)
	fmt.Println(x, y)
}
```

## 函数进阶 函数类型与函数值(闭包)
go语言本质都是**值**类型，函数是**函数值**类型。因此我们可以简单的声明一个函数类型
`var f func(x int, y int) int`  其零值为`nil`

```go
package main

import "fmt"

type myFunc func(x int, y int) int

func main() {
	var f1 func(a string) string //匿名函数类型
	fmt.Println(f1)              // nil

	var f2 myFunc = func(x int, y int) int{return x+y} //其中myFunc也可以省略
	fmt.Printf("%T\n",f2) // myFunc
	fmt.Println(f2(3, 4))

	var f3 = func(x int, y int) int { //函数值（一个函数的实现需要被使用）
		return x + y
	}
	fmt.Println(f3(1, 2)) // 3
}

//<nil>
//main.myFunc
//7
//3
```

接下来更加进一步的将函数表达式(函数变量)进行调用,`本质是匿名函数的调用`

- **函数调用表达式**直接返回结果值
- 匿名函数调用返回值

```go
var result = func(x,y int) int {
		return x+y
	}(11,2)
fmt.Println(result)
```

**函数值之间是不可以比较的，因此也不能作为map的key**
**函数值**不仅仅使我们可以使用**数据参数化函数**，也可以通过**行为**。 (函数可以**值参数化**和**行为参数化**)

```go
package main

import "fmt"

func main() {
	var a = add //var a int = add
	fmt.Println(a(3, 5))

	var b func(x,y int) int
	b = add
	fmt.Println(b(3,1))
}

func add(x, y int) int {
	return x + y
}
```

- 函数行为参数化

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Map(add1, "abcd"))
	fmt.Println(strings.Map(add1, "HAL-9000"))

}

func add1(r rune) rune {
	return r + 1
}
//bcde
//IBM.:111
```

### 匿名函数作为函数值在使用的时候定义

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.Map(func(r rune) rune {
		return r + 1
	}, "HAL-9000"))
}
```

匿名函数字面值表达式在使用时在定义，这种定义方式使得**匿名函数可以访问其所在函数的完整词法环境**。这意味着在函数中定义的**内部函数可以引用该函数的变量**。  

go使用闭包技术实现函数值，Go也把函数值称之为闭包。  

```go
package main

import (
	"fmt"
)

/*func square() int {
	var x int
	x++
	return func(x int) int {
		return  x * x
	}(x)
}*/


func square() func() int{
	var x int

	return func() int{
		x++
		fmt.Printf("%v\t%p\n",x,&x)
		return x*x
	}
}
func main() {
	f := square()
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
	
	/*
	1	0xc420070188
	1
	2	0xc420070188
	4
	3	0xc420070188
	9
	4	0xc420070188
	16
	*/

	//fmt.Println(square()())
	//fmt.Println(square()())
	//fmt.Println(square()())
	//fmt.Println(square()())
	//1	0xc42000e238
	//1
	//1	0xc42000e298
	//1
	//1	0xc42000e2c0
	//1
	//1	0xc42000e2e8
	//1
}

```

>squares的例子证明,函数值不仅仅是一串代码,还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量,这意味着匿名函数和squares中,存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包(closures)技术实现函数值,Go程序员也把函数值叫做闭包。

这里再次证明了变量的**作用域和生命周期是两个不同的概念，一个是静态的，一个是动态的。**  


### 函数值的重要特性-记录迭代变量的内存地址

golang中使用`:=`赋值初始化新变量，如果多次则会复用地址。这样在循环中，可以节省很多空间浪费。

```go
package main

import "fmt"

func main() {
	var strs = []string{"hello","world","china"}

	for _, v := range strs{
		fmt.Printf("%v\t%p\n", v,&v)
	}
	fmt.Printf("%v\n", "----------------")
	for _, v := range strs {
		v = v
		fmt.Printf("%v\t%p\n", v, &v)
	}

	fmt.Printf("%v\n", "----------------")
	for _, v := range strs {
		v := v
		fmt.Printf("%v\t%p\n", v, &v)
	}
}

// hello	0xc4200701b0
// world	0xc4200701b0
// china	0xc4200701b0
// ----------------
// hello	0xc420070200
// world	0xc420070200
// china	0xc420070200
// ----------------
// hello	0xc420070250
// world	0xc420070270
// china	0xc420070290
```

但是我们要说的重点是在于`for range`和闭包的结合使用，会产生的坑效果。

```go
	strs := []string{"hello", "world", "china"}
	for _, v := range strs {
		go func() {
			fmt.Println(v) //闭包 记录迭代变量的内存地址，而不是迭代某一刻的值！！
		}()
	}
	select {}

	//china
	//china
	//china
	//fatal error: all goroutines are asleep - deadlock!
	//
	//	goroutine 1 [select (no cases)]:
	//	main.main()
	//	/Users/fqc/work/src/myecho/main.go:14 +0xfc
	//	exit status 2

```
我们看到程序并未如我们所料，而是打印出了三次china，说明，v的地址是指向了最后的china，内部是函数闭包方式，产生了延迟调用，而v的地址在函数值被调用的时候已经是指向了最后的china。

原来**闭包~~函数值~~中记录迭代变量的内存地址，而不是迭代变量某一刻的值。单次执行看不出什么，但是在迭代中则会等待迭代执行完，才去执行函数值(闭包)**。  (迭代变量<->循环变量好多了)
在go语句和defer语句中也是如此。
所以需要**注意在循环体中将循环变量赋值给新的局部变量非常重要，否则每次获取的都是最后一次迭代值**。  


所谓闭包是指内层函数引用了外层函数中的变量或称为引用了自由变量的函数，其返回值也是一个函数，了解过的语言中有闭包概念的像 js，python，golang 都类似这样。


```go
strs := []string{"hello", "world", "china"}
	for _, v := range strs {
		go func(v string) {
			fmt.Println(v) //闭包函数值记录迭代变量的内存地址，而不是迭代某一刻的值！！
		}(v)
	}
	select {}
```
我们看到结果将会是strs数组的每个值。可以先忽略select{}，目前只是为了防止主routine先退出而看不到结果。



### 函数列表和匿名函数的使用不当

```go
package main

import "fmt"

func main() {
	for _, f := range test() {
		f()
	}
}

func test() []func() {
	var s []func()
	for i := 0; i < 3; i++ {
		s = append(s, func() {
			fmt.Printf("%v,%p\n", i, &i)
		})
	}
	return s
}

//3,0xc42007a050
//3,0xc42007a050
//3,0xc42007a050
```

解决方案
```go
func test() []func() {
	var s []func()
	for i := 0; i < 3; i++ {
		x := i
		/*	s = append(s, func(x int) {
				fmt.Printf("%v,%p\n", x, &x)
			}(x)) //这里就不应该调用啊
			*/
		s = append(s, func() {
			fmt.Printf("%v,%p\n", x, &x)
		})
	}
	return s
}
```


### 使用闭包修改全局变量
```go
package main                   

import (                       
    "fmt"                      
)                              

var x int = 1                  

func main() {                  
    y := func() int {          
        x += 1                 
        return x               
    }()                        
    fmt.Println("main:", x, y)                                                            
} 

// 结果：    main: 2 2
```
### 延迟调用
defer 调用会在当前函数执行结束前才被执行，这些调用被称为延迟调用，
defer 中使用匿名函数依然是一个闭包。


```go
package main

import "fmt"

func main() {
    x, y := 1, 2

    defer func(a int) { 
        fmt.Printf("x:%d,y:%d\n", a, y)  // y 为闭包引用
    }(x)      // 复制 x 的值

    x += 100
    y += 100
    fmt.Println(x, y)
}
```
输出结果：

101 102
x:1,y:102

```
从形式上看，匿名函数都是闭包。闭包的使用非常灵活，上面仅是几个比较简单的示例，不当的使用容易产生难以发现的 bug，当出现意外情况时，首先检查函数的参数，声明可以接收参数的匿名函数，这些类型的闭包问题也就引刃而解了。
```


中文版gotour

```sh
go get github.com/Go-zh/tour/gotour
cd $GOPATH/bin
./gotour
```
可以使本地英文版和中文版一起打开，只需修改下其中的一个的端口，然后需要构建下运行。
注意:使用go get下载时可能会出现网络问题你懂得，不过多试几次应该可以成功。
如果你定义好了$GOBIN,并加入到了path中，go get完成后，可以在任意位置使用`gotour`命令，但是你可能想要让自带的tour也能运行(其命令为go tool tour，端口为3999)，此时就需要修改中文本的端口，找到

```go
httpListen = flag.String("http","3999","host: port to listen on")
```
将3999修改为其他的可用端口。

## go语言数据类型
Go语言将数据类型分为四类:基础类型、复合类型、引用类型和接口类型。本章介绍基础类 型,包括:数字、字符串和布尔型。复合数据类型——数组(§4.1)和结构体(§4.2)——是 通过组合简单类型,来表达更加复杂的数据结构。引用类型包括指针(§2.3.2)、切片 (§4.2))字典(§4.3)、函数(§5)、通道(§8),虽然数据种类很多,但它们都是对程序 中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的 拷贝。
- 基础类型
  - 数字
  - 字符串
  - 布尔
  - error
- 复合类型(通过组合简单的基础类型组成复杂数据结构)
  - 数组
  - 结构体
- 引用类型(也属于复合类型，但是变量或状态的间接引用)
  - pointer
  - slice
  - map
  - function
  - channel
- 接口类型

## fmt的使用技巧
`fmt.Printf("%d %[1]d",10)`
通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数,但是%之后的`[1]`副词告诉Printf函数再次使用第一个操作数。第二,%后`#`副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```

```go
for x := 0; x < 8; x++ {
fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
}
打印e的幂,打印精度是小数点后三个小数精度和8个字符宽度
```

## NaN
```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
nan := math.NaN()
fmt.Printf("%f\n",nan)
fmt.Println(nan == nan, nan < nan, nan > nan)// false false false 注意:NaN和任何数都不相等
```

## error类型
error类型是go的内置类型，go中还有专门处理error类型的包errors

```go
err := errors.New("oops error")
if err != nil {
	fmt.Printf("%v\n", err)
}
```

