---
layout: post
title: Go基础之一 包、变量、函数
category: golang架构师之路
tags: golang,tour,function,variables,package
keywords: package,tour,function,variables 
---

## Go官方编程指南交互工具 tour
在安装好go环境之后，我们可以运行一个神奇的命令浏览器自动打开并跳转到Go官方提供的编程指南(本地服务，可以避免一些你懂的网络故障..)
```sh
$ go tool tour                                                                                                                                                [master|●2✚1…
23:38:05 Serving content from /usr/local/go/misc/tour
23:38:05 A browser window should open. If not, please visit http://127.0.0.1:3999
23:38:06 accepting connection from: 127.0.0.1:58925
```
也可以后台运行
```sh
$ nohup go tool tour & tour.log                                                                                                                               [master|●2✚1…
[1] 48104
appending output to nohup.out
zsh: command not found: tour.log

cat nohup.out                                                                                                                                               [master|●2✚1…
 23:49:30 Serving content from /usr/local/go/misc/tour
 23:49:30 A browser window should open. If not, please visit http://127.0.0.1:3999
 23:49:31 accepting connection from: 127.0.0.1:59131
 23:50:14 accepting connection from: 127.0.0.1:59142
 23:50:16 accepting connection from: 127.0.0.1:59143
 23:50:19 accepting connection from: 127.0.0.1:59144
 23:52:46 Serving content from /usr/local/go/misc/tour
 23:52:46 A browser window should open. If not, please visit http://127.0.0.1:3999
 23:52:47 accepting connection from: 127.0.0.1:59173
```

## 包
- 每个Go程序都是由包构成
- 程序入口在`main`包下
- 该示例程序`导入`了`fmt`和`math/rand`两个`路径`。
- 根据Go语言的惯例，`包名和导入路径的最后一个元素相同`。例如，"math/rand"包含在一个以`package rand`开头的文件。

```go
package main

import(
    "fmt"
    "math/rand"
)

func main(){
    fmt.Println("My favorite number is",rand.Intn(10))
}
```
注意： 这个程序的运行环境是固定的，因此 rand.Intn 总是会返回相同的数字。 （为了得到不同的数字，需要生成不同的种子数，参阅 rand.Seed。）
```go
func Seed(seed int64)
```
```go
    // rand.Seed(19990)固定种子，每次的结果都是一样
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    fmt.Println(r.Intn(1000))
```

## 导入
- 导入语句中使用了`()`打包多个导入路径，可以认为是"打包"导入方式，其实也可以分别导入(不推荐)，例如:
```sh
import "fmt"
import "math"
```
```go
package main

import "fmt"
import "math"

func main() {
    fmt.Println("Now you have %g problems.", math.Sqrt(7))
}
```

## `公有字段`
在Go语言里首字母大写的字段是公开的。例如，在`math`包中的`Pi`就是公开的可以被外部包访问的。

`pizza`和`pi`首字母非大写，所有他们为私有的，外部访问是会报错的。 

当导入包时你只能引用它的公开字段名称，任何一个`unexported`的名称或字段都不能被外部包所访问。 比如下面的示例，直接运行将会报错:
```go
package main

import "math"

func main() {
    func.Println(math.pi)//应该为Pi
}
```

```sh
$ go run tour-pacakge.go
# command-line-arguments
./tour-pacakge.go:12: cannot refer to unexported name math.pi
./tour-pacakge.go:12: undefined: math.pi
```
将`math.pi`修改为`math.Pi`即可正确运行。
```sh
$ go run tour-package.go
math.Pi is 3.141592653589793
```
## 函数
1. 函数可以带有0或多个参数。下面的示例中,`add`函数包含两个`int`类型的参数。
```go
package main

import "fmt"

func add(x int, y int) int {
    return x + y 
}

func main() {
    fmt.Println(add(40, 60))
}
```
注意**类型在变量的后面**。
可以参考Go的作者之一Rob Pike写的文章[《Go的声明语法》][0]解释为什么使用这种类型声明在后,字段名称在前的方式。

2. 当两个或更多连续的函数参数是同一种类型时，可以省略类型除了最后一个参数。  
例如: 
可以将`x int, y int` 简写为`x, y int`
上面的的add方法
```go
func add(x, y int) int {
    return x + y
}
```
## 多个返回值
Go函数可以有多个返回值。下面的`swap`函数返回两个字符串
```go
package main

import "fmt" // gogland(IDE) imp 当使用包组织方式而只有一个包路径时，删除后是可以自动补全包路径的，很智能

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)

}
```
## 命名返回值(naked return)
Go的返回值是可以命名的。如果那样他们将被当做变量声明在方法的签名上。

返回值的名称通常被用在标记返回值的含义上。

没有带参数的`return`语句块返回被命名的返回值。这被称作是"赤裸裸的"回报("naked" return)...即"裸"返回或者直接返回语句。  

直接返回语句仅应该用在短函数中，例如下面的示例。用在内容较长的函数中影响可读性。

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return //naked return
}

func main() {
	x, y := split(99)
	fmt.Println(x, y)
}
```
## 变量
`var`语句块定义一些列的变量；像在函数参数列表一样的方式，类型声明在最后。
`var`语句块可以为包或函数级别。例如示例:
```go
var c, java, python bool

func main() {
	var i int
	fmt.Println(i, c, java, python)
    //0 false false false
}
```
## 变量初始化器
变量声明定义可以包含一个初始值，每个变量一个。  
如果已经存在初始值，则可以省略类型；变量将采用初始值的类型。

```go
var i, j int = 1, 2

func main() {
    var c, java, python = true, false, "no!"
    fmt.Println(i, j, c, java, python)
}
```
## 短声明变量
在函数中，`:=`简洁赋值(短赋值块)可以使用于代替`var`定义。(隐藏着隐式类型的概念，也就是通过表达式的右边值或变量的类型进行类型推断而获得类型)
在函数外，每个语句都必须以关键词开始(`var,func`等等)，所以`:=`结构是不可以在函数外使用的
```go
func main() {
	var i, j int = 1, 2
	k := 3
	c, java, python := 100, 100, 100
	fmt.Println(i, j, k, c, java, python)
}
```
## 基本类型
Go的基本类型如下:
```sh
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point(Unicode码)

float32 float64

complex64 complex128
```
示例展示了几个类型变量，变量声明也可以"打包"到`var ()`中类似`import()`导入块

```go
func main() {
        var (
            ToBe   bool       = false
            MaxInt uint64     = 1<<64 - 1
            z      complex128 = cmplx.Sqrt(-5 + 12i)
        )
	fmt.Printf("Type: %T, Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T, Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T, Value: %v\n", z, z)
}
//Type: bool, Value: false
//Type: uint64, Value: 18446744073709551615
//Type: complex128, Value: (2+3i)
```
`int`,`uint`,`uintptr`类型通常在32位系统是32位，64位系统是64位。当你需要使用整型值的时候应该首先使用`int`类型，除非你有特殊的原因使用一个有大小的或无符号的整形。  

## 默认值
变量声明时没有给予特定的初始值时，Go会给予默认值(Zero value)。有人也翻译为"零值"。

默认值有以下几种:
* 数值型 `0` 
* 布尔型 `false`
* 字符型 `""`(空字符串)

```go
func main() {
    var i int
	var f string
	var b bool
	var s float64
	//fmt.Printf(i, f, b, s)//can not use i(int) as string
	fmt.Printf("%v,%q,%v,%v\n", i, f, b, s)
	fmt.Printf("%v,%v,%v,%v\n", i, f, b, s)
        //0,"",false,0 注意这里%q对于字符型值的作用
        //0,,false,0
}
```

## 类型转换
表达式`T(v)`将值`v`转换为`T`类型。  
一些数值型转换:
```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```
或者简写：
```go
i := 42
f := float64(i)
u := uint(f)
```
和C不一样，Go的分配赋值在不同类型之间需要显示转换。试试移除`float64`或`uint`在例子中的转换(注意是非简写的例子尝试)，看会发生什么。

```go
var o int = 56
var p float64 = o //Cannot use o(int) as float64 in assignment
var q uint = uint(p)

o := 55 // no new variables on left side of :=
//p := o
//q := uint(p)
fmt.Printf("%v,%v,%v", o, p, q)
```
在例如:
```go
func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt((x*x + y*y))//Cannot use (x*x+y*y)(type int) as float64 in assignment
	var z uint = uint(f)

	fmt.Println(x, y, z)

}
```
## 类型推断
当声明变量但没有明确指定其类型时(不论是使用`:=`还是`var =`表达式语法)，变量类型将从表达式的右边的值进行类型推断。
当表达式右边是已经声明过变量类型，新的变量则会和右边类型相同。例如:
```go
var i string
j := i // j的类型为string
fmt.Printf("%q,%q\n", i,j)
```
但是当表达式右边为没有指明类型的数字常量时，新的变量则可能为`int`、`float`、`complex128`进行推断，这就取决于常量的精度。
```go
i := 42 // int
f := 3.14 // float64
g := 0.876 + 0.5i // complex128
```

```go
func main() {
	v := 4322
	fmt.Printf("v is type of %T\n", v)
	x := float64(v)
	fmt.Printf("x is type of %T", x)
}

// v is type of int
// x is type of float64
```

## 常量
- 常量声明很像变量，只不过需要使用`const`关键字修饰
- 常量可以使字符，字符串，布尔或数值型
- 常量不能使用`:=`声明

```go
const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```

## 数值型常量
- 数值型常量是高精度的值。  
- 未指定类型的常量类型取决于上下文
- int可以最大可存储64位整数，有时可能少些取决于系统平台

```go
const (
	Big   = 1 << 100
	Small = Big >> 99
)

func needInt(x int) int { 
    return x*10 + 1 
}

func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
```





[0]:https://blog.go-zh.org/gos-declaration-syntax

































